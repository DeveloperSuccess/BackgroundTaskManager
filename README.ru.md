[![en](https://img.shields.io/badge/lang-en-red.svg)](./README.md)

# Событийный диспетчер отложенных задач на C#

[![NuGet version (DeferredTaskManager)](https://img.shields.io/nuget/v/DeferredTaskManager.svg?style=flat-square)](https://www.nuget.org/packages/DeferredTaskManager)

Реализация позволяет использовать несколько фоновых задач (или «раннеров») для отложенной обработки консолидированных данных. Раннеры построены на шаблоне PubSub для асинхронного ожидания новых задач, что делает этот подход более реактивным, но менее ресурсоемким.

## Отличительное преимущество

Решение позволяет производить консолидацию данных в текущей инстанции с возможностью вариативного проведения дедупликации или любых других операций на усмотрение разработчика, что может сократить ресурсы при дальнейшей передаче и обработке, а также увеличить быстродействие.

<p align="center">
<img align="center"  src="https://github.com/user-attachments/assets/8ff1e1c0-48c7-47ac-8647-165cae26b603" width=60%>
</p>

Оно было применено в моей работе по масштабированию WebSocket'ов в рамках микросервисной архитектуры, где консолидация и дедупликация событий перед их непосредственной отправкой оказали немаловажное влияние на быстродействие и потребление ресурсов за счет снижения накладных расходов.

<p align="center">
<img align="center"  src="https://github.com/user-attachments/assets/8e4eb390-9120-49b0-b7c4-bd2d4220c4fc" width=60%>
</p>

С внедрением `DeferredTaskManager` значительно сокращается `max(n)` запросов от каждой инстанции клиента за счет консолидации и дедупликации на их стороне. Например, вместо 1000 отдельных запросов будет отправлен всего один — что снижает накладные расходы на всех участках и увеличивает быстродействие системы в целом.

Если процесс доставки многоэтапный, и сервер в дальнейшей тоже является клиентом (например, играет роль хаба), использование в нём `DeferredTaskManager` тоже является целесообразным.

## Пример использования

### 1️⃣ Внедрение Singleton зависимости с требуемым типом данных
В качестве примера `DeferredTaskManager` регистрируется в `DI` с типом `string`:
```
services.AddDeferredTaskManager<string>(options =>
{
    options.PoolSize = Environment.ProcessorCount;
    options.CollectionType = CollectionType.Bag;
    options.SendDelayOptions = new SendDelayOptions()
    {
        MillisecondsSendDelay = 60000,
        ConsiderDifference = true
    };
    options.RetryOptions = new RetryOptions<string>
    {
        RetryCount = 3,
        MillisecondsRetryDelay = 10000,
    };
});
```
#### ⚪ `PoolSize` — размер пула (количество доступных раннеров)
Размер пула вариативен и подбирается разработчиком для конкретного спектра задач, ориентируясь на скорость выполнения и количество потребляемых ресурсов.
#### ⚪ `CollectionType` — тип коллекции
Можно указать тип коллекции хранения эвентов: «Bag» для неупорядоченной коллекции объектов (это работает быстрее) или «Queue» для упорядоченной коллекции объектов. Использовать «Queue» целесообразно только в том случае, если `PoolSize = 1`, в противном случае порядок выполнения не гарантирован. 
#### ⚪ `SendDelayOptions` — настройка отправки событий через временной интервал
Настраивает отправку добавленных событий на обработку через определенный промежуток времени с возможностью переменного вычета времени предыдущей операции. Имеет смысл указывать, когда при добавлении событий используется флаг `sendEvents = false`, который добавляет события без отправки на обработку.
#### ⚪ `RetryOptions` — настройка обработки исключений
Вы также можете указать параметры для повторных попыток обработки событий в случае возникновения исключений.

### Модули и их переопределение
  
Решение состоит из 5 модулей, каждый из которых регистрируется в DI.

  ⚪ `IDeferredTaskManagerService` — публичный интерфейс основного модуля, который имплементирует основные публичные методы для работы с диспетчером отложенных задач.
  
Для внутренего взаимодействия используются следующие публичные интерфейсы: 

  ⚪ `IEventSender` — отвечает за создание раннеров и содержит логику их поведения.
  
  ⚪ `IEventStorage` — прослойка для взаимодействия с хранилищем эвентов.
  
  ⚪ `IStorageStrategy` — используется для реализации хранилища эвентов.

  ⚪ `IPoolPubSub` — осуществляет взаимодействие с пулом фоновых раннеров.
  
Все эти интерфейсы публичные, но, фактически, для внешнего взаимодействия используется только `IDeferredTaskManagerService`. Реализацию каждого модуля можно переопределять, добавив собственные зависимости и логику (именно поэтому они тоже имеют публичные интерфейсы). 

Переопределять модули можно посредством отправки в метод регистрации DI `services.AddDeferredTaskManager` кастомных типов. Переопределяемый тип должен быть унаследован от одного из вышеперечисленных публичных интерфейсов.


### 2️⃣ Создание фоновой службы
В качестве примера приведено создание фоновой службы для `DeferredTaskManager<string>`:
```
internal sealed class EventManagerService : BackgroundService
{
    private readonly IDeferredTaskManagerService<string> _deferredTaskManager;

    public EventManagerService(IDeferredTaskManagerService<string> deferredTaskManager)
    {
        _deferredTaskManager = deferredTaskManager;
    }

    protected override Task ExecuteAsync(CancellationToken cancellationToken)
    {
       // Делегат для кастомной логики, в который поступают события от запущенных раннеров.
       // В качестве примера в нём производится конкатенация событий,
       // но возможна любая другая вариативная обработка или отправка куда-либо.
       Func<List<string>, CancellationToken, Task> eventConsumer = async (events, cancellationToken) =>
        {
            // Конкатенация событий
            var concatenatedEvents = string.Join(",", events);

            //throw new Exception("Тестовое исключение");

            // Любая дальнейшая обработка/отправка конкатенированных событий
            Thread.Sleep(1000);
            await Task.Delay(1000, cancellationToken);        
        };
        
        // Делегат, куда попадаем в случае возникновения исключений в основном делегате eventConsumer
        Func<List<string>, Exception, int, CancellationToken, Task> eventConsumerRetryExhausted = async (events, ex, retryCount, cancellationToken) =>
        {
            Console.WriteLine($"Повтор по счету: {retryCount}; {ex}");
        };

        return _deferredTaskManager.StartAsync(eventConsumer, eventConsumerRetryExhausted, cancellationToken);
    }
}
```
#### ⚪ `EventConsumer` — основной делегат для кастомной логики

Вся кастомная логика размещается в делегате `EventConsumer`, в который приходит коллекция консолидированных событий. Именно здесь можно осуществить необходимые операции над ними перед дальнейшей передачей/обработкой. Также в делегате можно обработать исключения (это актуально, если события обрабатываются по отдельности), отправив необработанные события на следующий заход после указанной в параметрах временной задержки `MillisecondsRetryDelay`. В приведенном примере в делегате выполняется конкатенация поступающих событий от запущенных раннеров.
В него можно добавить собственную логику обработки исключений, что может быть полезно, если эвенты обрабатываются отдельно: успешно завершенные эвенты можно удалить из основной коллекции эвентов, тогда незавершенные события пойдут в retry.
```
try
{
    // Кастомная логика

    // Тестовое исключение
    throw new Exception("Тестовое исключение");     
}
catch (Exception ex)
{
    // Любая кастомная логика (логирование и т. п.)

    // В случае обработки событий по отдельности,
    // можно удалить из коллекции эвентов успешно завершенные события,
    // тогда незавершенные события пойдут в retry
    events.RemoveRange(successEvents);   
}
```

#### ⚪ `EventConsumerRetryExhausted` — делегат для обработки исключений
По желанию можно указать этот делегат, попадание в который происходит в случае возникновения исключений в основном делегате `EventConsumer`. В нём можно осуществить логирование и другие кастомные операции.

### 3️⃣ Получение внедренной зависимости и осуществление добавления события(й)

```
_deferredTaskManager.Add(events);
```

## Альтернативные варианты использования
```DeferredTaskManager``` можно использовать как обычное хранилище событий, получая эвенты по требованию методом ```GetEventsAndClearStorage``` минуя раннеры, или осуществлять отправку доступных событий в делегат любому доступному раннеру по требованию — с помощью метода ```SendEvents```.
